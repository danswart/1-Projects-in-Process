---
title: "Almost a Working Flexdashboard-SCUC"
author: "Dan Swart"
output: 
  flexdashboard::flex_dashboard:
    css: swart-20240104.css
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```{r global, include=FALSE}

# Load Libraries
library(tidyverse)
library(qicharts2)
library(haven)
library(readxl)
library(skimr)
library(visdat)
library(gghighlight)
library(dplyr)
library(stringr)
library(ggtext)
library(gganimate)
library(ggplot2)
library(purrr)
library(scales)
library(ggrepel)
library(glue)             # concatenating strings
library(plotly)
library(htmlwidgets)
library(readr)
library(camcorder)
library(RColorBrewer)
library(rlang)
library(cowplot)
library(shiny)
library(flexdashboard)
library(DT)
library(htmltools)
library(shinyobjects)     # debugging shiny code
library(prettycode)
library(vroom)            # fast loading of data frames
library(tidylog)          # reports changes in console
library(janitor)
library(lubridate)
library(tsibble)          # working with time series data
library(tidytext)         # text analysis for chr columns
library(dlookr)           # diagnose and repair data frames; can compare distribs to normal
library(flextable)
library(patchwork)        # display multiple ggplot2 objects with various configs





# Reactive data storage
data_reactive <- reactiveVal(NULL)   # stores and updates a dataset during the runtime of the app.  This object is updated by 'observeEvent(input$file_chosen, {' in the server section.

column_choices <- reactiveVal(NULL)  # stores and updates column names for selection during the runtime of the app.  This object is updated by  'observeEvent(input$file_chosen, {' in the server section

column_data <- reactiveVal(NULL)     # stores and updates row contents of selected column(s) during the runtime. of the app.  This object is updated by 'observeEvent(input$file_chosen, { '   in the server section.

# Options
options(scipen = 999)
options(qic.clshade = T)                      # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.linecol = 'black')                # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.signalcol = "red")                # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.targetcol = "darkgreen")          # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(DT.options = list(dom = 'pBlfrti'))   # Add buttons, filtering, and top (t) pagination controls
options(shiny.maxRequestSize = 50 * 1024^2)   # Set upload maximum to 50 MB

# For testing you can Load the data
# df2 <- read_csv(here::here("data", "SCUC Snapshots 1995 to 2023-LONG.csv"))


# Load data locally if needed
# df2 <- read_csv(file = here::here("data/SCUC Snapshots 1995 to 2023-LONG.csv"))



# source("ds_style.R")


```





# Inputs {.sidebar data-width=350}


```{r}

# UI Components: These include both the sidebar UI and the main page content UI

#   Sidebar UI: Your inputs (defined with # Inputs {.sidebar})
#   Main content UI: Your visualization containers (e.g., # Run Chart)


##############################  SIDEBAR CHOICES THAT FEED SERVER FUNCTIONS

# File upload chooser button
fileInput(inputId = "file_chosen",
          label = "Choose a CVS File",
          accept = c(".csv")) 

# Check if file has a header
checkboxInput(inputId = "header",
              label = "Header",
              value = TRUE)

# Dropdown to choose the number of rows to display in Table
selectInput(
  inputId = "rows_per_page",
  label = "Rows per Page:",
  choices = c(10, 30, 50, 100, 200),
  selected = 30   # default value
  )

# Dropdown to choose the type of file to create when exporting
selectInput(
  inputId = "export_format",
  label = "Select Export Format:",
  choices = c("SVG", "PNG"),
  selected = "PNG" # Default value
)

# Choose type of data on Y axis
selectInput(
  inputId = "y_axis_type",
  label = "Y-Axis Data Type:",
  choices = c("Percentage" = "percent", 
              "Count" = "count", 
              "Currency" = "currency",
              "Other" = "other"),
  selected = "percent"
)

selectInput(
  inputId = "divide_by_100", 
  label =   "Divide values by 100?", 
  choices = c("Yes", "No"), 
  selected = "No"
  )

##############################  END OF SIDEBAR CHOICES THAT FEED SERVER FUNCTIONS



##############################  SIDEBAR CHOICES THAT DEPEND ON SERVER SECTION


# Dynamic drop downs for column selections appearing in the table
uiOutput("column_selections") 

# Slider for selecting year range
uiOutput("years_chosen")

# Dropdowns for X axis column selection
uiOutput("x_column_selected")

# Dropdowns for Y axis column selection
uiOutput("y_column_selected")

# Dropdown for Chart Title selection
uiOutput("chart_title_selected")      

# Dropdown for Chart Subtitle column selection
uiOutput("chart_subtitle_selected")   

# Dropdown for selecting grouping variable(s) for all charts that can display only 1 variable
uiOutput("line_group_selected")

# Dropdown for selecting grouping variable(s) for all charts that can display more than 1 variable
uiOutput("advanced_line_group_selected")


##############################  END OF SIDEBAR CHOICES THAT DEPEND ON SERVER SECTION


##############################  END OF SIDEBAR UI SECTION


```









# Server Logic {.hidden}


### Server Logic

```{r}

# Server Logic: This contains all your reactive expressions, render functions, etc.

#   This is your hidden section marked with # Server Logic {.hidden}

######################################   BEGIN SERVER SECTION   #############################
#############################################################################################


############################  SERVER - OBSERVE FUNCTION THAT UPDATES 3 GLOBAL REACTIVE OBJECTS

# File upload observer feeds 'column_data' to global data storage called 'column_data'
observeEvent(input$file_chosen, {
  req(input$file_chosen)

  # Read the CSV file
  data <- read_csv(input$file_chosen$datapath, col_names = TRUE)
  
  # Store data frame selected by user.  Updated when different data frame is chosen by user  
  data_reactive(data)     

  # Store column names in imported data frame.  Updated when different data frame is chosen by user
  column_choices(names(data))
  
  # Store unique values of row contents of each column name.  Updated when different data frame is chosen by user
  column_data(lapply(data, unique))     
   
  
})   

#################################  END OF OBSERVE FUNCTION THAT UPDATES 3 GLOBAL REACTIVE OBJECTS



#################################  SERVER - renderUI FUNCTIONS THAT UPDATE DROPDOWN CHOICES

# Generate dropdowns of column names for X axis selection
output$x_column_selected <- renderUI({
  req(column_choices())
  selectInput(
    inputId = "x_column",
    label = "Select X-Axis Column:",
    choices = column_choices(),  # these are row names of selected columns
    selected = "year"       # column_choices()[1] # Default selection
  )
})


# Generate dropdown of column names for Y axis selection
output$y_column_selected <- renderUI({
  req(column_choices())
  selectInput(
    inputId = "y_column",
    label = "Select Y-Axis Column:",
    choices = column_choices(),     # these are row names of selected columns
    selected = "value"              # column_choices()[2] # Default selection
  )
})


# Generate dropdown of column names for chart title selection
output$chart_title_selected <- renderUI({
  req(column_choices())
  selectInput(
    inputId = "chart_title",
    label = "Select Columns for Chart Title:",
    choices = column_choices(),
    selected = column_choices()[1],  # Default to first column
    multiple = TRUE  # Allow selecting multiple columns
  )
})



# Generate dropdown of column names for chart subtitle selection
output$chart_subtitle_selected <- renderUI({
  req(column_choices())
  selectInput(
    inputId = "chart_subtitle",
    label = "Select Value for Chart Subtitle:",
    choices = column_choices(),     # these are row names of selected columns
    selected = "year"              # column_choices()[2] # Default selection
  )
})


# Generate dynamic UI for selecting column contents
output$column_selections <- renderUI({
  req(column_choices())
  
  column_ui <- lapply(column_choices(), function(col_name) {
    selectInput(
      inputId = paste0("select_", col_name),
      label = paste("Select value for", col_name),
      choices = c("All", column_data()[[col_name]]),    # Add "All" to the choices
      selected = "",     # Default value
      multiple = TRUE     # Allow multiple selections
    )
  })
  
  do.call(tagList, column_ui)
})


# BASIC multi-line chart dropdown (for single category selection)
output$line_group_selected <- renderUI({
  req(column_choices())
  selectInput(
    inputId = "line_group",
    label = "For Line Chart: Select Category for Lines:",
    choices = column_choices(),
    selected = "group",
    multiple = FALSE  # Single selection only
  )
})

# ADVANCED multi-line chart dropdown (for multiple category selection)
output$advanced_line_group_selected <- renderUI({
  req(column_choices())
  selectizeInput(  # Using selectizeInput for better multiple selection
    inputId = "advanced_line_group",
    label = "For Line Charts:  Select Categories for Detailed Comparison:",
    choices = column_choices(),
    selected = "group",
    multiple = TRUE,  # Allow multiple selections
    options = list(plugins = list('remove_button'))
  )
})


# Generate dynamic year slider, if a "Year" column exists in the chosen data frame
output$years_chosen <- renderUI({
  req(data_reactive())
  
  # Check if there is a column named "Year" or similar
  year_col <- column_choices()[grepl("year", tolower(column_choices()))]
  
  # Retrieve min and max if 'year' column present for use in sliderInput
  if (length(year_col) > 0) {
    min_year <- min(data_reactive()[[year_col]], na.rm = TRUE)
    max_year <- max(data_reactive()[[year_col]], na.rm = TRUE)
    
  # Create slider input values for range of years
    sliderInput(
      inputId = "year_range",
      label = "Filter by Year Range:",
      min = min_year,
      max = max_year,
      value = c(min_year, max_year),
      step = 1,
      sep = ""
    )
  }
})


#################################  END OF renderUI FUNCTIONS THAT UPDATE DROPDOWN CHOICES



#################################  SERVER - reactive FUNCTIONS 

### The value returned by the reactive() expression will automatically update whenever its dependencies (i.e., inputs or other reactive values) change. 


filtered_data <- reactive({
  # Check if data is available
  req(data_reactive())
  
  # Start with the full data
  data <- data_reactive()
  
  # Apply column filters if any are selected
  for (col_name in column_choices()) {
    input_name <- paste0("select_", col_name)
    if (!is.null(input[[input_name]]) && length(input[[input_name]]) > 0) {
      if (!("All" %in% input[[input_name]])) {
        # Safely filter - check if column exists first
        if (col_name %in% names(data)) {
          data <- data[data[[col_name]] %in% input[[input_name]], , drop = FALSE]
        }
      }
    }
  }
  
  # Apply year range filter if a "Year" column exists
  if (!is.null(input$year_range)) {
    year_col <- column_choices()[grepl("year", tolower(column_choices()))]
    if (length(year_col) > 0 && year_col %in% names(data)) {
      year_filter <- data[[year_col]] >= input$year_range[1] & 
                      data[[year_col]] <= input$year_range[2]
      data <- data[year_filter, , drop = FALSE]
    }
  }
  
  # Return the filtered data, ensuring it's a data frame
  return(as.data.frame(data))
})


#################################  END OF reactive FUNCTIONS 




####################  SERVER - OBSERVE FUNCTION TO ANTICIPATE Y-AXIS DATA TYPE

# Auto-detect data type and suggest format
observe({
  req(filtered_data(), input$y_column)
  
  y_data <- filtered_data()[[input$y_column]]
  
  # Check if data looks like percentages (between 0 and 1)
  if (!is.null(y_data) && all(y_data >= 0 & y_data <= 1, na.rm = TRUE)) {
    updateSelectInput(session, "y_axis_type", selected = "percent")
  } 
  # Check if data looks like whole numbers/counts
  else if (!is.null(y_data) && all(abs(y_data - round(y_data)) < 0.001, na.rm = TRUE)) {
    updateSelectInput(session, "y_axis_type", selected = "count")
  }
  # Otherwise default to "other"
  else {
    updateSelectInput(session, "y_axis_type", selected = "other")
  }
  

})  

####################  END OF OBSERVE FUNCTION TO ANTICIPATE Y-AXIS DATA TYPE





######################################  BEGIN DATA TABLE LOGIC


output$data_frame_chosen <- renderDT({
  # Add debugging
  print("Attempting to render data table")

  # Check if filtered_data exists
  if (is.null(filtered_data())) {
    print("filtered_data is NULL")
    return(datatable(data.frame(Message = "No data available")))
  }

  # Check data type and structure
  print(paste("Class of filtered_data:", class(filtered_data())))
  print(paste("Dimensions:", paste(dim(filtered_data()), collapse = "x")))

  # Make sure it's a data frame
  if (!is.data.frame(filtered_data())) {
    print("Converting to data frame")
    data_to_show <- as.data.frame(filtered_data())
  } else {
    data_to_show <- filtered_data()
  }

  # Try to render the table
  tryCatch({
    datatable(
      data_to_show,
      style = 'bootstrap',
      editable = 'cell',
      filter = 'top',
      caption = htmltools::tags$caption(
        style = 'caption-side: top;
                text-align: center;
                padding-bottom: 10px;
                font-family: "Roboto", Roboto, Arial, sans-serif;
                font-weight: 900;
                font-size: 56;',
                'Table 2: ',
                htmltools::em('This is your data sorted and filtered per your inputs.')
      ),
      rownames = FALSE,
      extensions = "Buttons",
      options = list(
        striped = TRUE,
        spacing = "l",
        align = "lccccccr",
        digits = 1,
        width = "90%",
        pageLength = as.numeric(input$rows_per_page),
        paging = TRUE,
        ordering = TRUE,
        autoWidth = TRUE,
        scrollX = TRUE,
        scrollY = "400px",
        scrollCollapse = FALSE,
        buttons = c("copy", "csv", "excel", "pdf", "print"),
        responsive = TRUE
      ),
      class = "display compact stripe hover"
    )
  }, error = function(e) {
    print(paste("Error in datatable:", e$message))
    return(datatable(data.frame(Error = e$message)))
  })
})


###########################################  END DATA TABLE LOGIC




#########################################  BEGIN RUN CHART LOGIC

output$run_chart_plot <- renderPlot({
  req(filtered_data(), input$x_column, input$y_column, input$chart_title, input$year_range)

  # Extract x_data and y_data from filtered_data()
  data <- filtered_data()
  x_data <- data[[input$x_column]]
  y_data <- data[[input$y_column]]

  # Qualify the data
  req(!is.null(x_data), !is.null(y_data), length(x_data) > 0, length(y_data) > 0)

  # Calculate centerline (median)
  centerline <- median(y_data, na.rm = TRUE)

 
##############################  BUILD TITLE  
  
# Create a title_elements storage object to be filled by selection process below
title_elements <- c()     # placeholder

# Process each selected column
for(col_name in input$chart_title) {
  if(col_name %in% names(data)) {
    # If there's just one unique value in this column, use it
    if(length(unique(data[[col_name]])) == 1) {
      title_elements <- c(title_elements, as.character(unique(data[[col_name]])))
    }
    # If there are a few unique values (under 5), include them all
    else if(length(unique(data[[col_name]])) <= 5) {
      values <- paste(unique(data[[col_name]]), collapse=", ")
      title_elements <- c(title_elements, values)
    }
    # If there are many values, just indicate the count
    else {
      n_values <- length(unique(data[[col_name]]))
      title_elements <- c(title_elements, paste0(n_values, " Values"))
    }
  }
}


# Combine all elements with hyphens
title_content <- if (length(title_elements) > 0) {
  paste(title_elements, collapse = " - ")
} else {
  "Selected Data"  # Default if no columns selected
}

# Create the final title
title <- paste0(
  "<span style='color:darkorchid1'>",
  "Run Chart: ", 
  title_content,
  "</span>"
)

# create object chart_subtitle
chart_subtitle <- input$year_range

  subtitle <- paste0(
    "for the Years Ended ",
    chart_subtitle[1],
    " - ", 
    chart_subtitle[2]
  )
  
##############################  END OF BUILD TITLE    
  
  
# Create the run chart
  rc <- ggplot(data,
               aes(x = .data[[input$x_column]],
                   y = .data[[input$y_column]]
                   )
               ) +
    
    # Add lines connecting the points
    geom_line(color = "blue",
              linewidth = 1) +
    
    # Add points
    geom_point(size = rel(.90),
               color = "black"
               ) +
    
    # Add the centerline (median)
    geom_hline(yintercept = centerline, 
               linetype = "dashed",
               color = "black",
               linewidth = 1
               ) +
    
    # Add an annotation for the centerline
    annotate(
      "text",
      x = max(x_data, na.rm = TRUE),   # Place the annotation at far right edge
      y = max(y_data, na.rm = TRUE),   # Place the annotation at top
      label = "(centerline is the median)",
      color = "red",
      size = 4,
      hjust = -.5,     # pos number = Align slightly BELOW the line
      vjust = -1     # neg number = Align slightly ABOVE the line
    ) +

    labs(
      title = title,
      subtitle = subtitle,
      caption = "Note:  The centerline is the median",
      x = "Academic Year-Ended",
      y = "Values"
    )

  # Adjust Y axis  scales and labels based on data type
  if (input$y_axis_type == "percent") {
    rc <- rc + scale_y_continuous(
      labels = scales::percent_format(accuracy = 1),
      name = "Percentage"
    )
  } else if (input$y_axis_type == "count") {
    rc <- rc + scale_y_continuous(
      labels = scales::comma_format(),
      name = "Count"
    )
  } else if (input$y_axis_type == "currency") {
    rc <- rc + scale_y_continuous(
      labels = scales::dollar_format(),
      name = "Amount ($)"
    )
  } else {
    # Default - plain number format with appropriate decimal places
    rc <- rc + scale_y_continuous(
      labels = scales::number_format(accuracy = 0.01),
      name = "Value"
    )
  }
  
  # Set X axis  scales and labels 
rc <- rc + 
    scale_x_continuous(
      breaks = unique(data[[input$x_column]]),  # Show all unique years
      labels = function(x) format(x, scientific = FALSE)  # Format as regular numbers
    )
  
  
  # Continue adding theme elements
  rc <- rc + 
    # Set theme
    theme_minimal(base_size = 26) +
    # Add grid lines 
    theme(
      panel.grid.major = element_line(color = "gray",
                                      linewidth = 0.5
                                      ),
      panel.grid.minor = element_blank()
      ) +
    # remove legend
    theme(legend.position = "none") +
    
    theme(
      plot.title.position = "panel",
      text = element_text(color = "royalblue"),
      plot.title = ggtext::element_markdown(
         color = "darkgreen",
         size = rel(1.25),
         face = "bold",
         lineheight = 1.3,
         margin = margin(0, 0, 0.25, 0, "lines")
         ),

      plot.subtitle = ggtext::element_markdown(
         color = "darkgreen",
         size = rel(1.10),
         face = "bold",
         lineheight = 1.3,
         margin = margin(0, 0, 0.5, 0, "lines")
         ),

      plot.caption = element_text(color = "darkgreen",
                                  size = rel(1.0),
                                  face = "bold",
                                  lineheight = 1.0,
                                  margin = margin(0, 0, 0.5, 0, "lines")
                                  ),

      strip.text = element_text(color = "orange",
                                size = rel(1.1),
                                face = "bold",
                                margin = margin(2, 0, 0.5, 0, "lines")
                                ),

      # X-axis tick label styling
      axis.text.x = element_text(
        angle = 45,
        hjust = 1,
        face = "bold", 
        size = rel(1.1)
      ),
      
      # X-axis title styling
      axis.title.x = element_text(
       face = "bold", 
       size = rel(1.3),
       color = "royalblue",  # Optional: specify color
       margin = margin(t = 10)
      ),
      
      # y-axis tick label styling
      axis.text.y = element_text(
        hjust = 1,
        face = "bold", 
        size = rel(1.1)
      ),
      
       # y-axis title styling
       axis.title.y = element_text(
        face = "bold", 
        size = rel(1.1),
        color = "royalblue",  # Optional: specify color
        margin = margin(t = 10, r = 10)
       ),
      
      panel.background = element_rect(fill = "white", color = NA),
      
      plot.background = element_rect(fill = "white", color = NA)
  )

  # Return the ggplot object directly
  return(rc)
  
  
})   


########################################  END OF RUN CHART LOGIC





########################################  BUILD LINE PLOT (CAN HANDLE MULTIPLE LINES) 

output$advanced_line_plot <- renderPlot({
  req(filtered_data(), input$x_column, input$y_column, input$chart_title, 
      input$year_range, input$advanced_line_group)
  
  # Make sure we have at least one grouping variable selected
  req(length(input$advanced_line_group) > 0)

  # Extract data from filtered_data()
  data <- filtered_data()
  
  # Safely create the combined group column
  if(length(input$advanced_line_group) == 1) {
    # If only one column is selected, use it directly
    data$combined_group <- as.character(data[[input$advanced_line_group]])
  } else {
    # For multiple columns, create a combined string
    # First, check all columns exist
    all_cols_exist <- all(input$advanced_line_group %in% names(data))
    if(!all_cols_exist) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, 
                        label = "Error: Some selected group columns don't exist in the data") + 
               theme_void())
    }
    
    # Now combine the columns safely
    data$combined_group <- apply(data[, input$advanced_line_group, drop = FALSE], 1, 
                              function(row) paste(row, collapse = " | "))
  }
  
  
  
##############################  BUILD TITLE FOR ADVANCED LINE PLOT
 
   
  # Create an object used in the Subtitle 
  groups_title <- paste(input$advanced_line_group, collapse = ", ")
  
  # Create a combined title from user-selected columns (same as in previous function)
  title_elements <- c()
  for(col_name in input$chart_title) {
    if(col_name %in% names(data)) {
      if(length(unique(data[[col_name]])) == 1) {
        title_elements <- c(title_elements, as.character(unique(data[[col_name]])))
      } else if(length(unique(data[[col_name]])) <= 5) {
        values <- paste(unique(data[[col_name]]), collapse=", ")
        title_elements <- c(title_elements, values)
      } else {
        n_values <- length(unique(data[[col_name]]))
        title_elements <- c(title_elements, paste0(n_values, " Values"))
      }
    }
  }

  # Combine title elements
  title_content <- if (length(title_elements) > 0) {
    paste(title_elements, collapse = " - ")
  } else {
    "Selected Data"
  }

  # Create the final title and subtitle
  title <- paste0(
    "<span style='color:darkorchid1'>",
    "Line Chart: ", 
    title_content,
    "</span>"
  )

  subtitle <- paste0(
    "for Years ", input$year_range[1], " - ", input$year_range[2]
    # " (Comparing by: ", groups_title, ")"
  )
  
##############################  END OF BUILD TITLE FOR ADVANCED LINE PLOT


  
##############################  BUILD LINE PLOT

  # Create the advanced multi-line chart
  alc <- ggplot(data,
               aes(x = .data[[input$x_column]],
                   y = .data[[input$y_column]],
                   color = combined_group,      # Color by combined groups
                   group = combined_group       # Group by combined groups
                   )
               ) +
    
    # Add lines connecting the points
    geom_line(linewidth = 1.2) +
    
    # Add points
    geom_point(size = 4) +
    
    # If we have many categories, use a different color scale
    {if(length(unique(data$combined_group)) <= 9) {
        scale_color_brewer(palette = "Set1")
      } else {
        scale_color_viridis_d()
      }} +
    
    labs(
      title = title,
      subtitle = subtitle,
      caption = paste("Detailed comparison by", groups_title),
      x = input$x_column,
      y = input$y_column,
      color = "Categories"  # Legend title
    )

  # Adjust Y axis scales and labels based on data type
  if (input$y_axis_type == "percent") {
    alc <- alc + scale_y_continuous(
      labels = scales::percent_format(accuracy = 1),
      name = "Percentage"
    )
  } else if (input$y_axis_type == "count") {
    alc <- alc + scale_y_continuous(
      labels = scales::comma_format(),
      name = "Count"
    )
  } else if (input$y_axis_type == "currency") {
    alc <- alc + scale_y_continuous(
      labels = scales::dollar_format(),
      name = "Amount ($)"
    )
  } else {
    alc <- alc + scale_y_continuous(
      labels = scales::number_format(accuracy = 0.01),
      name = "Value"
    )
  }
  
  # Set X axis scales and labels 
  alc <- alc + 
    scale_x_continuous(
      breaks = unique(data[[input$x_column]]),
      labels = function(x) format(x, scientific = FALSE)
    )
  
  # Apply the same theme as before
  alc <- alc + 
    theme_minimal(base_size = 26) +
    theme(
      panel.grid.major = element_line(color = "gray", linewidth = 0.5),
      panel.grid.minor = element_blank(),
      plot.title.position = "panel",
      text = element_text(color = "royalblue"),
      plot.title = ggtext::element_markdown(
         color = "darkgreen",
         size = rel(1.25),
         face = "bold",
         lineheight = 1.3,
         margin = margin(0, 0, 0.25, 0, "lines")
      ),
      plot.subtitle = ggtext::element_markdown(
         color = "darkgreen",
         size = rel(1.10),
         face = "bold",
         lineheight = 1.3,
         margin = margin(0, 0, 0.5, 0, "lines")
      ),
      plot.caption = element_text(
        color = "darkgreen",
        size = rel(1.0),
        face = "bold",
        lineheight = 1.0,
        margin = margin(0, 0, 0.5, 0, "lines")
      ),
      strip.text = element_text(
        color = "orange",
        size = rel(1.1),
        face = "bold",
        margin = margin(2, 0, 0.5, 0, "lines")
      ),
      axis.text.x = element_text(
        angle = 45,
        hjust = 1,
        face = "bold", 
        size = rel(1.1)
      ),
      axis.title.x = element_text(
       face = "bold", 
       size = rel(1.3),
       color = "royalblue",
       margin = margin(t = 10)
      ),
      axis.text.y = element_text(
        hjust = 1,
        face = "bold", 
        size = rel(1.1)
      ),
      axis.title.y = element_text(
        face = "bold", 
        size = rel(1.1),
        color = "royalblue",
        margin = margin(t = 10, r = 10)
      ),
      # Adjust legend for potentially many categories
      legend.position = "right",
      legend.title = element_text(face = "bold", size = rel(1.0)),
      legend.text = element_text(size = rel(0.9)),
      legend.key.size = unit(0.8, "cm"),
      # If we have many categories, make the legend more compact
      {if(length(unique(data$combined_group)) > 10) {
         legend.key.height = unit(0.8, "cm")
       }},
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA)
    )
  
  # Return the ggplot object
  return(alc)
  
  
})

########################################  END OF ADVANCED LINE CHART (MULTIPLE LINES) 
  





########################################  BEGIN BAR CHART LOGIC


output$bar_chart <- renderPlot({
  req(filtered_data(), input$x_column, input$y_column, input$chart_title, 
      input$year_range, input$advanced_line_group, input$y_axis_type, input$divide_by_100)
  
  # Make sure we have at least one grouping variable selected
  req(length(input$advanced_line_group) > 0)
  # Extract data from filtered_data()
  data <- filtered_data()
  
  # Safely create the combined group column
  if(length(input$advanced_line_group) == 1) {
    # If only one column is selected, use it directly
    data$combined_group <- as.character(data[[input$advanced_line_group]])
  } else {
    # For multiple columns, create a combined string
    # First, check all columns exist
    all_cols_exist <- all(input$advanced_line_group %in% names(data))
    if(!all_cols_exist) {
      return(ggplot() + 
               annotate("text", 
                        x = 0.5, 
                        y = 0.5, 
                        label = "Error: Some selected group columns don't exist in the data") + 
               theme_void())
    }
    
    # Now combine the columns safely
    data$combined_group <- apply(data[, input$advanced_line_group, drop = FALSE], 1, 
                              function(row) paste(row, collapse = " | "))
  }
  
  # Create a title showing what we're comparing
  groups_title <- paste(input$advanced_line_group, collapse = ", ")
  
  # Create a combined title from user-selected columns
  title_elements <- c()
  for(col_name in input$chart_title) {
    if(col_name %in% names(data)) {
      if(length(unique(data[[col_name]])) == 1) {
        title_elements <- c(title_elements, as.character(unique(data[[col_name]])))
      } else if(length(unique(data[[col_name]])) <= 5) {
        values <- paste(unique(data[[col_name]]), collapse=", ")
        title_elements <- c(title_elements, values)
      } else {
        n_values <- length(unique(data[[col_name]]))
        title_elements <- c(title_elements, paste0(n_values, " Values"))
      }
    }
  }
  
  # Set the plot title based on collected title elements
  plot_title <- "Bar Plot"
  if(length(title_elements) > 0) {
    plot_title <- paste(title_elements, collapse = " - ")
  }
  
  # Process data according to divide_by_100 input
  if(input$divide_by_100 == "Yes") {
    # Divide values by 100 (e.g., convert 75 to 0.75)
    data[[input$y_column]] <- data[[input$y_column]] / 100
  }
  
  # Prepare y-axis label
  y_axis_label <- input$y_column
  if(input$y_axis_type == "Percentage") {
    data[[input$y_column]] <- data[[input$y_column]] * 100
    y_axis_label <- "Percentage (%)"
  } else if(input$y_axis_type == "Count") {
    y_axis_label <- "Count"
  } else if(input$y_axis_type == "Currency") {
    y_axis_label <- "Amount ($)"
  }
  
  # Ensure x-axis column is treated as a factor to show all values
  data[[input$x_column]] <- as.factor(data[[input$x_column]])
  
  # Create the base plot
  p <- ggplot(data,
              aes(
                x = .data[[input$x_column]],
                y = .data[[input$y_column]], 
                fill = .data$combined_group
              )) +
    
    geom_col(position = position_dodge(width = 0.9),
             color = "black",
             fill = 'lightblue',
             alpha = 0.95,
             linewidth = 0.5) +
    
    labs(
      title = plot_title,
      x = input$x_column,
      y = y_axis_label,
      fill = groups_title
    )
  
  # Add type-specific formatting
  if(input$y_axis_type == "Percentage") {
    # Hard-code the percentage formatter
    p <- p + scale_y_continuous(
      labels = function(y) paste0(format(y, nsmall = 0), "%")
    )
  } else if(input$y_axis_type == "Currency") {
    p <- p + scale_y_continuous(labels = scales::dollar)
  } else {
    p <- p + scale_y_continuous(labels = scales::comma)
  }
  
  # Force display of all x-axis labels
  p <- p + scale_x_discrete(
    breaks = levels(as.factor(data[[input$x_column]])) # Explicitly define every break
  )
  
  # Apply theming
  p <- p + theme_minimal(base_size = 36) +
    
    theme(
      panel.grid.major = element_line(color = "gray", linewidth = 0.5),
      
      panel.grid.minor = element_blank(),
      
      legend.position = "none",
      
      plot.title = element_text(hjust = 0.5, size = rel(1.00), face = "bold"),
      
      axis.title = element_text(size = rel(1.00)),
      
      axis.text = element_text(size = rel(.90)),
      
      # Ensure x-axis text is angled
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
      
      legend.title = element_text(size = rel(.90)),
      
      legend.text = element_text(size = rel(.90))
      
    )
  
  # Return the completed plot
  return(p)
})



#####################################  END OF BAR CHART LOGIC





#####################################  BEGIN UNTRENDED I-CHART LOGIC



output$untrended_i_chart <- renderPlot({
  # Require necessary inputs
  req(
    filtered_data(), input$x_column, input$y_column, input$chart_title,
    input$year_range, input$advanced_line_group, input$y_axis_type, input$divide_by_100
  )

  # Extract data from filtered_data()
  df1 <- filtered_data()

  # Make sure we have some data
  if (nrow(df1) == 0) {
    return(ggplot() +
      annotate("text",
        x = 0.5,
        y = 0.5,
        label = "No data available with current filters"
      ) +
      theme_void())
  }

  # Process data for control limits calculation
  df1_control_limits <- df1

  # Process data according to divide_by_100 input
  if (input$divide_by_100 == "Yes") {
    # Divide values by 100 (e.g., convert 75 to 0.75)
    df1_control_limits[[input$y_column]] <- df1_control_limits[[input$y_column]] / 100
  }

  # For percentage display, convert to percentage for visualization
  if (input$y_axis_type == "Percentage") {
    df1_control_limits[[input$y_column]] <- df1_control_limits[[input$y_column]] * 100
  }

  ### CALCULATE UNTRENDED CL, SD AND CONTROL LIMITS ###
  emp_cl <- mean(df1_control_limits[[input$y_column]], na.rm = TRUE) # Calculate empirical centerline

  emp_sd <- mean(abs(diff(df1_control_limits[[input$y_column]])), na.rm = TRUE) / 1.128 # Calculate empirical standard deviation

  emp_lcl <- max(emp_cl - (3 * emp_sd), 0) # If LCL is negative, set it to zero

  emp_ucl <- emp_cl + (3 * emp_sd) # Calculate empirical upper control limit

  # Create modified dataset for chart
  df1_modified <- df1

  # Process data according to divide_by_100 input
  if (input$divide_by_100 == "Yes") {
    # Divide values by 100 (e.g., convert 75 to 0.75)
    df1_modified[[input$y_column]] <- df1_modified[[input$y_column]] / 100
  }
  # For percentage display, convert to percentage for visualization
  if (input$y_axis_type == "Percentage") {
    df1_modified[[input$y_column]] <- df1_modified[[input$y_column]] * 100
  }

  # Shewhart Rule #1: violations if value is outside UCL or LCL
  sigma_signals <- df1_modified[[input$y_column]] < emp_lcl | df1_modified[[input$y_column]] > emp_ucl
  emp_pts_out_of_control <- sigma_signals

  # Add the 'out_of_control' column to the dataframe
  df1_modified$emp_pts_out_of_control <- emp_pts_out_of_control

  # Runs analysis for changing CL color and linetype
  runs <- sign(df1_modified[[input$y_column]] - emp_cl)
  runs <- runs[runs != 0]
  runs_lengths <- rle(runs)$lengths
  n_obs <- sum(runs_lengths)
  longest_run <- max(runs_lengths)
  n_runs <- length(runs_lengths)
  n_crossings <- n_runs - 1
  longest_run_max <- round(log2(n_obs) + 3)
  n_crossings_min <- qbinom(.05, n_obs - 1, 0.5)

  runs_signal <- (longest_run > longest_run_max | n_crossings < n_crossings_min)

  # ADD EMPIRICAL CL, SD, UCL, LCL AND RUNS_SIGNAL TO df1_modified
  df1_modified <- df1_modified %>%
    dplyr::mutate(
      emp_cl = emp_cl, # add empirical centerline
      emp_sd = emp_sd, # add empirical standard deviation
      emp_lcl = emp_lcl, # add empirical lcl
      emp_ucl = emp_ucl, # add empirical upper control limit
      runs_signal = as.logical(runs_signal) # Ensure it's a column, not a constant
    )

  # Replace zeros in the value column with NA
  df1_modified[[input$y_column]] <- ifelse(df1_modified[[input$y_column]] == 0,
    NA,
    df1_modified[[input$y_column]]
  )

  # Compute x and y positions for geom_richtext
  x_pos <- min(df1_modified[[input$x_column]], na.rm = TRUE)
  y_pos <- max(df1_modified[[input$y_column]], na.rm = TRUE)

  # Get descriptive information from filtered data
  desired_years <- unique(df1_modified[[input$x_column]])


##############################  BUILD TITLE

  
  # Create a combined title from user-selected columns (same as in previous function)
  title_elements <- c()
  for(col_name in input$chart_title) {
    if(col_name %in% names(df1_modified)) {
      if(length(unique(df1_modified[[col_name]])) == 1) {
        title_elements <- c(title_elements, as.character(unique(df1_modified[[col_name]])))
      } else if(length(unique(df1_modified[[col_name]])) <= 5) {
        values <- paste(unique(df1_modified[[col_name]]), collapse=", ")
        title_elements <- c(title_elements, values)
      } else {
        n_values <- length(unique(df1_modified[[col_name]]))
        title_elements <- c(title_elements, paste0(n_values, " Values"))
      }
    }
  }


  # Combine title elements
  title_content <- if (length(title_elements) > 0) {
    paste(title_elements, collapse = " - ")
  } else {
    "Selected Data"
  }

  # Create the final title and subtitle
  i_title <- paste0(
    "<span style='color:darkorchid1'>",
    "Untrended Process Chart: ",
    title_content,
    "</span>"
  )

  i_subtitle <- paste0(
    "for Years ", input$year_range[1], " - ", input$year_range[2]
    )


  ##############################  END OF BUILD TITLE


# 
#   # Create dynamic title and subtitle using input values
#   i_title <- paste0(
#     "Untrended Process Chart:  ", title_content   #input$chart_title
#   )
# 
#   i_subtitle <- paste0(
#     "For the Years ", min(desired_years), " - ", max(desired_years)
#   )

  
  
  
  # Create y-axis label based on type
  y_axis_label <- input$y_column

  if (input$y_axis_type == "Percentage") {
    y_axis_label <- "Percentage (%)"
  } else if (input$y_axis_type == "Count") {
    y_axis_label <- "Count"
  } else if (input$y_axis_type == "Currency") {
    y_axis_label <- "Amount ($)"
  }

  # Create caption
  caption <- "\n Source: Texas Education Agency"

  # Create plot object I-chart USING GGPLOT2 ONLY
  i_chart <- ggplot2::ggplot(
    df1_modified,
    aes(
      x = .data[[input$x_column]],
      y = .data[[input$y_column]]
    )
  ) +

    # Add lines connecting the points
    ggplot2::geom_line(
      color = "darkgray",
      linewidth = 2.0
    ) +

    # Use 'color' to map logical TRUE/FALSE to red/black points
    ggplot2::geom_point(aes(color = factor(emp_pts_out_of_control)),
      size = 8
    ) +
    ggplot2::scale_color_manual(values = c(
      "TRUE" = "red",
      "FALSE" = "blue"
    )) +

    # CL line type depends on value of runs_signals
    geom_line(aes(
      y = emp_cl,
      linetype = factor(runs_signal)
      )
      ) +


    scale_linetype_manual(values = c("FALSE" = "solid",
                                     "TRUE" = "dashed"
                                     )
                          ) +

    # Format emp_ucl LINE
    ggplot2::geom_line(aes(y = emp_ucl),
      color = "red",
      linetype = "solid",
      linewidth = 2
    ) +

    # Format emp_lcl LINE
    ggplot2::geom_line(aes(y = emp_lcl),
      color = "red",
      linetype = "solid",
      linewidth = 2
    ) +

    # Add labels
    ggplot2::labs(
      title = i_title,
      subtitle = i_subtitle,
      caption = caption,
      x = input$x_column,
      y = y_axis_label
    ) +

    # Disclose CL calculation
    ggtext::geom_richtext(
      aes(
        label = paste0("<b><i>UPL, CL, LPL are based on all filtered data</i></b>"),
        x = x_pos,
        y = y_pos
      ),
      size = 10,
      color = "black",
      hjust = -.40,
      vjust = -5,
      fill = "lightblue",
      label.color = "black"
    ) +

    # Disclose CL line type
    ggtext::geom_richtext(
      aes(
        label = paste0("<b><i>If run rules violated, centerline will be dashed line</i></b>"),
        x = max(df1_modified[[input$x_column]], na.rm = TRUE),
        y = min(df1_modified[[input$y_column]], na.rm = TRUE)
      ),
      size = 10,
      color = "black",
      hjust = 1,
      vjust = 5,
      fill = "pink",
      label.color = "black"
    )

  # Configure x-axis to show all years
  if (is.numeric(df1_modified[[input$x_column]])) {
    i_chart <- i_chart +
      ggplot2::scale_x_continuous(
        breaks = unique(df1_modified[[input$x_column]]),
        expand = c(
          0.15,
          0.00
        )
      )
  } else {
    # For character/factor columns, use discrete scale
    i_chart <- i_chart +
      ggplot2::scale_x_discrete(
        expand = c(
          0.15,
          0.00
        )
      )
  }

  # Configure y-axis based on chart type
  if (input$y_axis_type == "Percentage") {
    i_chart <- i_chart +
      ggplot2::scale_y_continuous(
        labels = function(y) paste0(format(y, nsmall = 0), "%"),
        expand = c(
          0.25,
          0.25
        )
      )
  } else if (input$y_axis_type == "Currency") {
    i_chart <- i_chart +
      ggplot2::scale_y_continuous(
        labels = scales::dollar,
        expand = c(0.25, 0.25)
      )
  } else {
    i_chart <- i_chart +
      ggplot2::scale_y_continuous(
        labels = scales::comma,
        expand = c(
          0.25,
          0.25
        )
      )
  }

  # Set base size for all future fonts
  i_chart <- i_chart + ggplot2::theme_minimal(base_size = 36)

  # Theme and title the plot object
  i_chart <- i_chart +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(angle = 45,
                                          hjust = 1
                                          ),

      legend.position = "none",

      plot.title.position = "panel",

      text = ggplot2::element_text(color = "royalblue"),
      plot.title = ggtext::element_markdown(
        color = "darkgreen",
        size = ggplot2::rel(1.25),
        face = "bold",
        lineheight = 1.1,
        margin = ggplot2::margin(2, 0, 0, 0, "lines")
      ),

      plot.subtitle = ggtext::element_markdown(
        color = "darkgreen",
        size = ggplot2::rel(1.1),
        face = "bold",
        lineheight = 1.0,
        margin = ggplot2::margin(0, 0, 0, 0, "lines")
      ),

      plot.caption = ggplot2::element_text(
        size = ggplot2::rel(.95),
        hjust = 0,
        vjust = 2,
        face = "italic",
        color = "darkblue"
      ),

      strip.text = ggplot2::element_text(
        color = "orange",
        size = ggplot2::rel(1.1),
        face = "italic",
        margin = ggplot2::margin(2, 0, 0.5, 0, "lines")
      ),

      axis.text = ggplot2::element_text(color = "black"),

      panel.background = ggplot2::element_rect(fill = "white", color = NA),

      plot.background = ggplot2::element_rect(fill = "white", color = NA)
    )

  # Add labels for control limits
  i_chart <- i_chart +
    ggplot2::geom_text(
      aes(
        x = dplyr::first(!!sym(input$x_column)),
        y = dplyr::first(emp_cl),
        label = "CenterLine"
      ),
      color = "blue",
      vjust = -1,
      hjust = 1.1,
      size = 10
    ) +

    # Format CL text
    ggplot2::geom_text(
      aes(
        x = dplyr::last(!!sym(input$x_column)),
        y = dplyr::last(emp_cl),
        label = format(round(dplyr::last(emp_cl), 2))
      ),
      color = "blue",
      vjust = 0,
      hjust = -0.1,
      size = 10
    ) +

    ggplot2::geom_text(
      aes(
        x = dplyr::first(!!sym(input$x_column)) + 0.5,
        y = dplyr::first(emp_ucl),
        label = "Upper Process Limit"
      ),
      color = "red",
      vjust = -1,
      hjust = 1.1,
      size = 10
    ) +

    # Format emp_ucl
    ggplot2::geom_text(
      aes(
        x = dplyr::last(!!sym(input$x_column)),
        y = dplyr::last(emp_ucl),
        label = format(round(dplyr::last(emp_ucl), 2))
      ),
      color = "red",
      vjust = -1,
      hjust = -0.1,
      size = 10
    ) +

    # Format emp_lcl
    ggplot2::geom_text(
      aes(
        x = dplyr::first(!!sym(input$x_column)) + .5,
        y = dplyr::first(emp_lcl),
        label = "Lower Process Limit"
      ),
      color = "red",
      vjust = 1.75,
      hjust = 1.1,
      size = 10
    ) +

    # Format FIRST emp_ucl
    ggplot2::geom_text(
      aes(
        x = dplyr::last(!!sym(input$x_column)),
        y = dplyr::last(emp_lcl),
        label = format(round(dplyr::last(emp_lcl), 2))
      ),
      color = "red",
      vjust = 1.5,
      hjust = -0.1,
      size = 10
    )

  # Add padding to individual plots
  i_chart <- i_chart +
    ggplot2::theme(
      plot.margin = ggplot2::margin(
        t = 0,
        r = 0,
        b = 0,
        l = 0
      )
    )

  # Return the chart
  return(i_chart)
})


#####################################  END OF UNTRENDED I-CHART LOGIC



###################################  END OF SERVER LOGIC SECTION  ###########################
#############################################################################################

```




<!-- ####################  VISUALIZATIONS SECTION -->


# Data Table {data-icon="fa-signal" data-width=500}

```{r}

# Output title with styling
tags$h2("CLICK ON COLUMNS TO SORT",
        style = "text-align: center;
        font-size: 20px;
        font-weight: bold;
        color: #2E86C1;")


DTOutput("data_frame_chosen")

```



# Run Chart  {data-icon="fa-signal" data-width=500}

```{r}

# plotlyOutput("run_chart_plot")

plotOutput("run_chart_plot")

```




# Bar Chart  {data-icon="fa-signal" data-width=500}

```{r}

plotOutput("bar_chart")


```


# Line Chart  {data-icon="fa-signal" data-width=500}

### Line Chart

```{r}
plotOutput("advanced_line_plot",
           height = "600px")

```


# Untrended I-Chart  {data-icon="fa-signal" data-width=500}


```{r}

plotOutput("untrended_i_chart", height = "800px")

```



<!-- ####################  END OF VISUALIZATIONS SECTION -->






